; Test optimization remarks generated by the LoopInterchange pass.
;
; RUN: opt < %s -basicaa -loop-interchange -pass-remarks-output=%t -pass-remarks-missed='loop-interchange' \
; RUN:          -pass-remarks='loop-interchange' -S
; RUN: cat %t |  FileCheck %s

@A = common global [100 x [100 x i32]] zeroinitializer
@B = common global [100 x [100 x i32]] zeroinitializer
@C = common global [100 x i32] zeroinitializer

;;---------------------------------------Test case 01---------------------------------
;; Loops interchange is not profitable, as the induction variable of the inner
;; loop is already used to access continuous elements in the array.
;;
;; The cost of interchanging the loops is 180, because with the original loop
;; order, all 3 accesses can make use of full cache lines (192 bytes in cache).
;; When the loops are interchanged, only a single element fits in cache lines
;; for each access (12 bytes in cache).
;;
;;   for(int i=1;i<N;i++)
;;     for(int j=1;j<N;j++)
;;       A[i-1][j-1] = A[i - 1][j-1] + B[i][j];

define void @test01(i32 %N){
entry:
  %cmp31 = icmp sgt i32 %N, 1
  br i1 %cmp31, label %for.cond1.preheader.lr.ph, label %for.end19

for.cond1.preheader.lr.ph:
  %0 = add i32 %N, -1
  br label %for.body3.lr.ph

for.body3.lr.ph:
  %indvars.iv34 = phi i64 [ 1, %for.cond1.preheader.lr.ph ], [ %indvars.iv.next35, %for.inc17 ]
  %1 = add nsw i64 %indvars.iv34, -1
  br label %for.body3

for.body3:
  %indvars.iv = phi i64 [ 1, %for.body3.lr.ph ], [ %indvars.iv.next, %for.body3 ]
  %2 = add nsw i64 %indvars.iv, -1
  %arrayidx6 = getelementptr inbounds [100 x [100 x i32]], [100 x [100 x i32]]* @A, i64 0, i64 %1, i64 %2
  %3 = load i32, i32* %arrayidx6
  %arrayidx10 = getelementptr inbounds [100 x [100 x i32]], [100 x [100 x i32]]* @B, i64 0, i64 %indvars.iv34, i64 %indvars.iv
  %4 = load i32, i32* %arrayidx10
  %add = add nsw i32 %4, %3
  store i32 %add, i32* %arrayidx6
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %lftr.wideiv = trunc i64 %indvars.iv to i32
  %exitcond = icmp eq i32 %lftr.wideiv, %0
  br i1 %exitcond, label %for.inc17, label %for.body3

for.inc17:
  %indvars.iv.next35 = add nuw nsw i64 %indvars.iv34, 1
  %lftr.wideiv37 = trunc i64 %indvars.iv34 to i32
  %exitcond38 = icmp eq i32 %lftr.wideiv37, %0
  br i1 %exitcond38, label %for.end19, label %for.body3.lr.ph

for.end19:
  ret void
}

; CHECK: --- !Missed
; CHECK-NEXT: Pass:            loop-interchange
; CHECK-NEXT: Name:            InterchangeNotProfitable
; CHECK-NEXT: Function:        test01
; CHECK-NEXT: Args:
; CHECK-NEXT:  - String:          'Interchanging loops is too costly (cost='
; CHECK-NEXT:  - Cost:            '180'
; CHECK-NEXT:  - String:          ', threshold='
; CHECK-NEXT:  - Threshold:       '0'
; CHECK-NEXT:  - String:          ') and it does not improve parallelism.'
; CHECK-NEXT: ...
